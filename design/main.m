%**************************************************************************************************
%Author: Yong Wang
%Last Edited: 25/03/2010
%Email: ywang@csu.edu.cn; wangyong1226@gmail.com
%Reference:        Combining Multiobjective Optimization with Differential Evolution
%                                         to Solve Constrained Optimization Problems
%                               IEEE Transactions on Evolutionary Computation, Accepted
%**************************************************************************************************

%  The description of some important parameters
%              P:     main population
%             fit:      the fitness of the population P
%             mu:    the number of individuals for crossover
%              Q:     the set of individuals for crossover
%          fit_Q:    the fitness of the set Q
%              C:     the set of individuals generated by crossover
%          fit_C:    the fitness of the set C

% profile on;

clc; 
clear all; 

tic; 

format long; 
format compact; 

'CMODE'

mu = 15  %popsize=180, mu=6 is successful for g23 F=0.5+rand*0.1;%origin CR=0.9+rand*0.25;

dimension = 0;
% Select which problem to be tested
%1 Welded beam design
%2 Tession compression spring design
%3 Speed reducer design
%4 Three-bar truss design
%5 Himmelblau¡¯s Nonlinear Optimization Problem
problemSet = [1 2 3 4 5]; 
optimal=[2.38095658 0.012665233 2994.471066 263.8958434 -31025.56024];

maxFES = 50000;
for problemIndex = 1 : 5
    problem = problemSet(problemIndex)
    popsize = 100
  
    switch problem

        case 1

            % lu: define the upper and lower bounds of the variables
            lu = [0.125 0.1 0.1 0.1; 10.0 10.0 10 10.0]; 
            % n: define the dimension of the problem
            n = 4; aaa = []; 

        case 2

            lu = [0.25 0.05 2.0; 1.3 2.0 15.0]; 
            n = 3; aaa = []; 

        case 3

            lu = [2.6 0.7 17 7.3 7.3 2.9 5.0; 3.6 0.8 28 8.3 8.3 3.9 5.5]; 
            n = 7; aaa = []; 

        case 4

            lu = [0 0; 1 1]; 
            n = 2; aaa = []; 

%         case 5
% 
%             lu = [0.0625 0.0625 10.0 10.0; 99*0.0625 99*0.0625 240 240];
%             n = 4; aaa = [];
%         case 6
% 
%             lu = [0.0625 0.0625 10.0 10.0; 99*0.0625 99*0.0625 240 240];
%             n = 4; aaa = [];

        case 5

            lu = [78 33 27 27 27; 102 45 45 45 45]; 
            n = 5; aaa = [];
    end

    % Record the best results
    bestResults  = []; 
    % Record the feasibility proportion of the population
    feasiPro = []; 

    %Main body
 
    time = 1; 
    totalTime=5;
    bestFES1=[];
    success=0;
  
    numberMin = 1;
    percent = 0.10;

%     numberMax = floor(popsize*percent);
    numberMax = 1;
    alphabet = (numberMin:numberMax); 
    overall = numberMax*(numberMin+numberMax)/2;
%     prob = (numberMax/overall :0: numberMax/overall);
    prob = (numberMax/overall :-1/overall : numberMin/overall);
    prob1 = (numberMax/overall :0 : numberMin/overall);
    while time <= totalTime
        bestValue = 1E10;
        time
        rand('seed', sum(100 * clock)); 
        FES = 0;
%         % Initialize the main population
        P = ones(popsize, 1) * lu(1, :) + rand(popsize, n) .* (ones(popsize, 1) * (lu(2, :) - lu(1, :))); 
        fit = fitness(P, problem); 
      
        FES=FES+popsize;
        bestFES = 0;
        number = randsrc(10000,1,[alphabet; prob]) ;
        while FES <= maxFES
            % Randomly select mu individuals from P that constitute the set
            % Q
%             randSel = floor(rand(1, mu) * popsize*1) + 1;
              a = randperm(popsize);
              randSel = a(1:mu);
              Q = P(randSel, :); 
              fitQ = fit(randSel, :); 
            
           vioSum = sum(fit(:, 2 : size(fit, 2)), 2);
%            vioSum = vioSum./numbers;
           %Sort all the solutions in P in ascending order by their degree of constraint violations
            [vioVal, vioIndex] = sort(vioSum);
            % Sort the feasible solutions in D in ascending order by their objective function values
             feasiIndex  =  find(vioVal  ==  0);
             proportion = size(feasiIndex, 1)/popsize;
        if rand <1% 1*(1-proportion)
    %     Compute the degree of constraint violations of P
            vioSum = sum(fit(:, 2 : size(fit, 2)), 2);
%             vioSum = vioSum - epsilon;
%             vioSum(vioSum < 0) = 0;
           %Sort all the solutions in P in ascending order by their degree of constraint violations
            [vioVal, vioIndex] = sort(vioSum);
            temP = P(vioIndex, :);
            temfitP = fit(vioIndex, :);
            % Sort the feasible solutions in D in ascending order by their objective function values
             feasiIndex  =  find(vioVal  ==  0);
           if ~isempty(feasiIndex)
                [feasiObjVal, feasiObjIndex]  =  sort(temfitP(feasiIndex, 1));
                temP(feasiIndex, :)  =  temP(feasiObjIndex, :);
                temfitP(feasiIndex, :)  =  temfitP(feasiObjIndex, :);
           end
        else
            temP = P;
            temfitP = fit;  
            [~, objIndex] = sort(temfitP(:, 1));
            temP = temP(objIndex, :);
            temfitP = temfitP(objIndex, :);
        end
         
               bestIndividual=temP(1:popsize, :);
               fitbestIndividual=temfitP(1:popsize, :);
         
           C = DE1(P, fit, Q, fitQ, 1, mu, popsize, lu, n, bestIndividual, fitbestIndividual, FES, maxFES, numberMax, alphabet, prob, number);
              [fitC, nonVal] = fitness(C, problem);
            FES=FES+mu;
    
            [P, fit]=models1(P, fit, Q, fitQ, C, fitC, randSel, mu, 0);
            % Compute the degree of constraint violations of P
            vioSumP = sum(fit(:, 2 : size(fit, 2)), 2);
            % Find the best individual in P
            feasiIndex = find(vioSumP == 0);

            if ~isempty(feasiIndex)
                [minFeasiVal, minFeasiIndex] = min(fit(feasiIndex, 1));
                if minFeasiVal < bestValue 
                    bestValue = minFeasiVal;
                    bestFES = FES;
                    
                    bestIndex = feasiIndex(minFeasiIndex);
                end
                
            else
               [bestVal, bestIndex] = min(vioSumP);
            end
        end

        % Compute the degree of constraint violations of P
        vioSumP = sum(fit(:, 2 : size(fit, 2)), 2);
        % Record the best results and the feasibility proportion
        feasiIndex = find(vioSumP == 0); 
        if ~isempty(feasiIndex)
%             [~, index] = min(fit(feasiIndex, 1));
%             P(feasiIndex(index), :)
%             fit(feasiIndex(index), 1)
            bestResults = [bestResults min(fit(feasiIndex, 1))]; 
            feasiPro = [feasiPro length(feasiIndex) / popsize]; 
            bestFES1=[bestFES1, bestFES];
        else
            [minVioValP, minVioIndexP] = min(vioSumP); 
            bestResults = [bestResults fit(minVioIndexP, 1)]; 
            feasiPro = [feasiPro 0]; 
            bestFES1=[bestFES1, 0];
        end
        time = time + 1;
    end
    success
    % Show the best results and the feasibility proportion
%     bestResults 
    sort(bestResults)
    meanResult = mean(bestResults)
    stdResult = std(bestResults)
    success
    bestFES1
    meanFES = mean(bestFES1)
    feasiPro
    %mean(bestFES1)
end

toc; 

% profview
